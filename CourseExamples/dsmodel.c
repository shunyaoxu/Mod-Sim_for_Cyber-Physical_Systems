#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model CourseExamples.Workshop14.ControlledMotor
 Dymola Version 2021x (64-bit), 2020-11-26 translated this at Sun Apr 11 18:50:59 2021

   */
#define PrintEvent_ 263168

#include <matrixop.h>
#if defined(DynSimStruct) || defined(BUILDFMU)
static double DymArrays0[4]={0.0, 0.0, 0.0, 0.0};
#endif
/* Declaration of C-structs */
struct DymStruc0;
struct DymStruc0 {
  double  V_0member;
  double  ILinear_0member;
};
DYMOLA_STATIC struct DymStruc0 DymStruc0_construct(double   ILinear_02, double  
   V_02) {
  struct DymStruc0 dummy_0;
  dummy_0.ILinear_0member = ILinear_02;
  dummy_0.V_0member = V_02;
  return dummy_0;
}
/* Prototypes for functions used in model */
DYMOLA_STATIC double   Modelica_Electrical_Machines_Losses_DCMachines_brushVoltageDrop
  (struct DymStruc0 brushParameters0_0, double  i0_0);
/* Codes used in model */

/* Flattened Modelica model:

function Modelica.Electrical.Machines.Losses.DCMachines.brushVoltageDrop
parameter input Modelica.Electrical.Machines.Losses.BrushParameters brushParameters;
discrete input Real i(unit = "A") "Actual current";
discrete output Real v(unit = "V") "Voltage drop";

algorithm 
if (brushParameters.V <= 0) then 
v := 0;
else
v := (if i > brushParameters.ILinear then brushParameters.V else (if i <  -brushParameters.ILinear then  -brushParameters.V else brushParameters.V*i/brushParameters.ILinear));
end if;
end Modelica.Electrical.Machines.Losses.DCMachines.brushVoltageDrop;

  */
DYMOLA_STATIC double   Modelica_Electrical_Machines_Losses_DCMachines_brushVoltageDrop
  (struct DymStruc0 brushParameters0_0, double  i0_0) {
  PushContext("Modelica.Electrical.Machines.Losses.DCMachines.brushVoltageDrop")
  {
    /* Declare outputs and temporaries */
    double   v0_0;
    v0_0=0;
    /* Start of real code */
      if (brushParameters0_0.V_0member <= 0) {
        v0_0 = 0;
      }
      else{
        v0_0 = IF i0_0 > brushParameters0_0.ILinear_0member THEN 
          brushParameters0_0.V_0member ELSE IF i0_0 <  -brushParameters0_0.
          ILinear_0member THEN  -brushParameters0_0.V_0member ELSE divGuarded(
          brushParameters0_0.V_0member*i0_0,"brushParameters.V*i",
          brushParameters0_0.ILinear_0member,"brushParameters.ILinear");
      }
    /* Output section */
    PopContext()
    return v0_0;
  }}
/* DSblock C-code: */

BreakSectionFunctionDef(1)
BreakSectionFunctionDef(0)
#define NX_    5
#define NX2_   0
#define NU_    0
#define NY_    0
#define NW_    255
#define NP_    52
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   0
#define MAXAuxStr_   0
#define MAXAuxStrLen_   500
#define NHash1_ -1705745748
#define NHash2_ -850244864
#define NHash3_ 0
#define NI_    0
#define NRelF_ 2
#define NRel_  2
#define NTim_  2
#define NSamp_ 0
#define NCons_ 0
#define NA_    167
#define SizePre_ 0
#define SizeEq_ 2
#define SizeDelay_ 0
#define QNLmax_ 0
#define MAXAux 0
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 12
#define NGlobalHelpI_ 0
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="CourseExamples.Workshop14.ControlledMotor";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/xsy98/appdata/roaming/dassaultsystemes/dymola/dymola.lic";
#define QJacobianCGDef_ 1
DYMOLA_STATIC int QJacobianCG_[12]={4 , 2 , 1 , 3 , 1 , 2 , 1 , 4 , 1 , 5 , 0 , 0};
static int QJacobianGrp0[6]={1, 1, 0, 0, 0, 0};
static int QJacobianGrp1[6]={2, 2, 2, 2, 2, 0};
static int QJacobianGrp2[6]={4, 0, 0, 4, 0, 0};
static int QJacobianGrp3[6]={5, 0, 0, 5, 5, 0};
DYMOLA_STATIC struct QJacobianTag_ QJacobianGC2_[5]={
{0, QJacobianGrp0},{0, QJacobianGrp1},{0, QJacobianGrp2},{0, QJacobianGrp3},
  {0,0}};
DYMOLA_STATIC double QJacobianCD_[6]={0  , 44 , 50 , 66 , 63 , 64};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,1) = false;
DYNX(W_,3) = false;
DYNX(W_,14) = 3;
DYNX(W_,21) = 3;
DYNX(W_,37) = true;
DYNX(W_,74) = true;
DYNX(W_,84) = true;
DYNX(W_,99) = true;
DYNX(W_,115) = true;
DYNX(W_,119) = false;
DYNX(W_,120) = 293.15;
DYNX(W_,150) = 3.141592653589793;
DYNX(W_,151) = false;
DYNX(W_,190) = true;
DYNX(W_,204) = 3;
DYNX(W_,205) = false;
DYNX(W_,212) = 4;
DYNX(W_,213) = false;
DYNX(W_,217) = 1;
DYNX(W_,230) = true;
DYNX(W_,231) = true;
DYNX(W_,233) = false;
DYNX(W_,240) = false;
DYNX(W_,241) = false;
DYNX(W_,165) = 0.0005;
DYNX(W_,166) = 0;
DYNX(W_,0) = 147.6548547187203;
DYNX(W_,5) = 147.6548547187203;
DYNX(W_,7) = 0.001;
DYNX(W_,8) = 0.14765485471872028;
DYNX(W_,31) = 147.6548547187203;
DYNX(W_,34) = 0.001;
DYNX(W_,35) = 0.14765485471872028;
DYNX(W_,42) = 1;
DYNX(W_,45) = 147.6548547187203;
DYNX(W_,46) = 0;
DYNX(W_,48) = 0.00014765485471872027;
DYNX(W_,51) = 147.6548547187203;
DYNX(W_,80) = false;
DYNX(W_,92) = 1;
DYNX(W_,95) = 147.6548547187203;
DYNX(W_,96) = 0.0;
DYNX(W_,98) = 0.00014765485471872027;
DYNX(W_,112) = 147.6548547187203;
DYNX(W_,134) = 293.15;
DYNX(W_,137) = 293.15;
DYNX(W_,140) = 293.15;
DYNX(W_,144) = 293.15;
DYNX(W_,197) = 0.0005;
DYNX(W_,167) = false;
DYNX(W_,174) = 0.0005;
DYNX(W_,175) = 1;
DYNX(W_,198) = 0.0;
DYNX(W_,194) = 0.0;
DYNX(W_,195) = false;
DYNX(W_,214) = 1;
DYNX(W_,215) = 2;
DYNX(W_,216) = false;
DYNX(W_,227) = false;
DYNX(W_,228) = 2;
DYNX(W_,242) = 1;
DYNX(W_,249) = 1;
DYNX(W_,4) = 0;
DYNX(W_,43) = 0;
DYNX(W_,49) = 0;
DYNX(W_,53) = 0;
DYNX(W_,235) = true;
DYNX(W_,89) = 0;
DYNX(W_,105) = 0;
DYNX(W_,206) = 0;
DYNX(W_,196) = 0;
DYNX(W_,172) = 0.0;
DYNX(W_,81) = 0;
DYNX(W_,173) = 0;
DYNX(W_,234) = 0;
DYNX(W_,236) = 0;
DYNX(W_,26) = 0;
DYNX(W_,106) = 0;
DYNX(W_,22) = 0.0;
DYNX(W_,24) = 0.0;
DYNX(W_,23) = 0.0;
DYNX(W_,18) = 0.0;
DYNX(W_,57) = 0.0;
memcpy(&DYNX(W_,61), &DymArrays0, sizeof(double)*4);
DYNX(W_,103) = 0;
memcpy(&DYNX(W_,122), &DymArrays0, sizeof(double)*4);
DYNX(W_,179) = 0;
DYNX(W_,183) = 0.0;
DYNX(W_,246) = 0;
DYNX(W_,245) = false;
DYNX(W_,200) = 0.0;
DYNX(W_,86) = 0.0;
DYNX(W_,85) = 293.15;
DYNX(W_,87) = 0.0;
DYNX(W_,176) = 0.0;
DYNX(W_,180) = 0.0;
DYNX(W_,178) = 0.0;
DYNX(W_,177) = 0.0;
DYNX(W_,181) = 0.0;
DYNX(W_,101) = 0.0;
DYNX(W_,100) = 293.15;
DYNX(W_,91) = 0.0;
DYNX(W_,102) = 0.0;
DYNX(W_,90) = 0.0;
DYNX(W_,39) = 0.0;
DYNX(W_,38) = 293.15;
DYNX(W_,40) = 0.0;
DYNX(W_,27) = 0.0;
DYNX(W_,29) = 0.0;
DYNX(W_,182) = 0.0;
DYNX(W_,185) = 0.0;
DYNX(W_,184) = 0.0;
DYNX(W_,25) = 0.0;
DYNX(W_,19) = 0.0;
DYNX(W_,41) = 0.0;
DYNX(W_,155) = 0.0;
DYNX(W_,163) = 0.0;
DYNX(W_,162) = 293.15;
DYNX(W_,157) = 0.0;
DYNX(W_,156) = 293.15;
DYNX(W_,161) = 0.0;
DYNX(W_,160) = 293.15;
DYNX(W_,164) = 0.0;
DYNX(W_,159) = 0.0;
DYNX(W_,158) = 293.15;
DYNX(W_,193) = 0.0;
DYNX(W_,117) = 0.0;
DYNX(W_,116) = 293.15;
DYNX(W_,118) = 0.0;
DYNX(W_,107) = 0.0;
DYNX(W_,109) = 0.0;
DYNX(W_,146) = 0.0;
DYNX(W_,145) = 293.15;
DYNX(W_,136) = 0.0;
DYNX(W_,135) = 293.15;
DYNX(W_,142) = 0.0;
DYNX(W_,141) = 293.15;
DYNX(W_,139) = 0.0;
DYNX(W_,138) = 293.15;
DYNX(W_,133) = 0.0;
DYNX(W_,132) = 293.15;
DYNX(W_,127) = 0.0;
DYNX(W_,126) = 293.15;
DYNX(W_,131) = 0.0;
DYNX(W_,130) = 293.15;
DYNX(W_,129) = 0.0;
DYNX(W_,128) = 293.15;
DYNX(W_,199) = 0.0;
DYNX(W_,201) = 0.0;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
DYNX(W_,2) = DYNX(DP_,8);
DYNX(W_,6) = IF DYNX(W_,4) <= 0 THEN 0 ELSE divGuarded(DYNX(W_,4),
  "motor.motor.frictionParameters.PRef",DYNX(W_,5),"motor.motor.frictionParameters.wRef");
DYNX(W_,9) = IF DYNX(W_,4) <= 0 THEN 0 ELSE DYNX(W_,6)*powGuarded(divGuarded(
  DYNX(W_,8),"motor.motor.frictionParameters.wLinear",DYNX(W_,5),
  "motor.motor.frictionParameters.wRef"),"motor.motor.frictionParameters.wLinear/motor.motor.frictionParameters.wRef",
  DYNX(DP_,9),"motor.motor.frictionParameters.power_w");
DYNX(W_,13) = DYNX(DP_,8);
DYNX(W_,20) = DYNX(W_,2);
DYNX(W_,30) = DYNX(W_,4);
DYNX(W_,32) = DYNX(DP_,9);
DYNX(W_,33) = DYNX(W_,6);
DYNX(W_,36) = DYNX(W_,9);
DYNX(W_,54) = 0.01*DYNX(DP_,2);
DYNX(DYNhelp,0) = 1+DYNX(DP_,6)*(DYNX(DP_,5)-293.15);
DYNX(DYNhelp,1) = 1+divGuarded(DYNX(DP_,6)*(DYNX(DP_,3)-DYNX(DP_,5)),
  "motor.motor.alpha20a*(motor.motor.TaNominal-motor.motor.TaRef)",
  DYNX(DYNhelp,0),"1+motor.motor.alpha20a*(motor.motor.TaRef-293.15)");
DYNX(DYNhelp,2) = 1+DYNX(DP_,14)*(DYNX(DP_,13)-293.15);
DYNX(DYNhelp,3) = 1+divGuarded(DYNX(DP_,14)*(DYNX(DP_,15)-DYNX(DP_,13)),
  "motor.motor.alpha20e*(motor.motor.TeNominal-motor.motor.TeRef)",
  DYNX(DYNhelp,2),"1+motor.motor.alpha20e*(motor.motor.TeRef-293.15)");
DYNX(DYNhelp,4) = (PushModelContext(1,"Modelica.Electrical.Machines.Losses.DCMachines.brushVoltageDrop(\nmotor.motor.brushParameters, \nmotor.motor.IaNominal)")
  Modelica_Electrical_Machines_Losses_DCMachines_brushVoltageDrop(
  DymStruc0_construct(DYNX(W_,54), DYNX(W_,53)), DYNX(DP_,2)));
PopModelContext();
DYNX(W_,152) = DYNX(DP_,1)-(DYNX(DP_,4)*DYNX(DYNhelp,1)+DYNX(DP_,12)*
  DYNX(DYNhelp,3))*DYNX(DP_,2)-DYNX(DYNhelp,4);
AssertModelica(DYNX(W_,152) > 1E-15,"motor.motor.ViNominal > 1E-15", 
  "VaNominal has to be > (Ra[+Rse])*IaNominal");
DYNX(W_,44) = DYNX(W_,152);
DYNX(W_,47) = IF DYNX(W_,43) <= 0 THEN 0 ELSE divGuarded(divGuarded(DYNX(W_,43),
  "motor.motor.coreParameters.PRef",sqr(DYNX(W_,44)),"motor.motor.coreParameters.VRef^2"),
  "motor.motor.coreParameters.PRef/motor.motor.coreParameters.VRef^2",
  DYNX(W_,42),"motor.motor.coreParameters.m");
DYNX(W_,50) = DYNX(DP_,2);
DYNX(W_,52) = IF DYNX(W_,49) <= 0 THEN 0 ELSE divGuarded(DYNX(W_,49),
  "motor.motor.strayLoadParameters.PRef",DYNX(W_,51),"motor.motor.strayLoadParameters.wRef");
DYNX(W_,69) = DYNX(DP_,4);
DYNX(W_,70) = DYNX(DP_,5);
DYNX(W_,71) = divGuarded(DYNX(DP_,6),"motor.motor.alpha20a",1+DYNX(DP_,6)*(
  DYNX(DP_,5)-293.15),"1+motor.motor.alpha20a*(motor.motor.TaRef-293.15)");
DYNX(W_,75) = DYNX(W_,70);
DYNX(W_,79) = DYNX(DP_,7);
DYNX(W_,82) = DYNX(W_,53);
DYNX(W_,83) = DYNX(W_,54);
DYNX(W_,93) = DYNX(W_,43);
DYNX(W_,94) = DYNX(W_,44);
DYNX(W_,97) = DYNX(W_,47);
DYNX(W_,110) = DYNX(W_,49);
DYNX(W_,111) = DYNX(W_,50);
DYNX(W_,113) = DYNX(DP_,11);
DYNX(W_,114) = DYNX(W_,52);
DYNX(W_,121) = DYNX(DP_,0);
DYNX(W_,143) = DYNX(W_,121);
AssertModelica(1+DYNX(W_,71)*(DYNX(W_,143)-DYNX(W_,70)) >= 1E-15,
  "1+motor.motor.ra.alpha*(motor.motor.thermalAmbient.constTa.k-motor.motor.ra.T_ref) >= 1E-15",
   "Temperature outside scope of model!");
DYNX(W_,147) = DYNX(DP_,16);
DYNX(W_,149) = DYNX(W_,147);
DYNX(DYNhelp,5) = fabs(DYNX(DP_,2));
DYNX(W_,153) = DYNX(W_,197)*DYNX(DYNhelp,5);
DYNX(W_,154) = divGuarded(DYNX(W_,152),"motor.motor.ViNominal",DYNX(W_,0)*
  DYNX(W_,153),"motor.motor.wNominal*motor.motor.psi_eNominal");
DYNX(W_,168) = DYNX(W_,154);
DYNX(W_,186) = DYNX(DP_,12);
DYNX(W_,187) = DYNX(DP_,13);
DYNX(W_,188) = divGuarded(DYNX(DP_,14),"motor.motor.alpha20e",1+DYNX(DP_,14)*(
  DYNX(DP_,13)-293.15),"1+motor.motor.alpha20e*(motor.motor.TeRef-293.15)");
AssertModelica(1+DYNX(W_,188)*(DYNX(W_,149)-DYNX(W_,187)) >= 1E-15,
  "1+motor.motor.re.alpha*(motor.motor.thermalAmbient.constTse.k-motor.motor.re.T_ref) >= 1E-15",
   "Temperature outside scope of model!");
DYNX(W_,191) = DYNX(W_,187);
DYNX(W_,203) = DYNX(DP_,18);
DYNX(W_,207) = DYNX(DP_,17);
DYNX(W_,219) = DYNX(DP_,28);
DYNX(W_,221) = DYNX(DP_,23);
DYNX(W_,225) = DYNX(DP_,26);
DYNX(W_,226) = DYNX(DP_,27);
AssertModelica(DYNX(W_,225) >= DYNX(W_,226),"PID.limiter.uMax >= PID.limiter.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(W_,225), true, 0)),") < uMin (="),Real2String2(DYNX(W_,226),
   true, 0)),")"));
PopAllMarks();
DYNX(W_,232) = DYNX(DP_,32);
DYNX(W_,238) = DYNX(DP_,29);
DYNX(DYNhelp,6) = divinvGuarded(DYNX(DP_,24),"PID.Ti");
DYNX(W_,239) = DYNX(DYNhelp,6);
DYNX(W_,243) = DYNX(DP_,33);
DYNX(W_,247) = DYNX(DP_,25);
DYNX(DYNhelp,7) = divinvGuarded(DYNX(DP_,31),"PID.Nd");
DYNX(W_,248) = RealBmax(DYNX(DYNhelp,7)*DYNX(DP_,25), 1E-14);
DYNX(W_,250) = DYNX(DP_,34);
DYNX(DYNhelp,8) = fabs(DYNX(W_,247));
DYNX(W_,251) = DYNX(DYNhelp,8) < 1E-15;
DYNX(W_,254) = divinvGuarded(DYNX(DP_,23)*DYNX(DP_,30),"PID.k*PID.Ni");
BoundParameterConstantSection
DYNX(W_,76) = DYNX(W_,69)*(1+DYNX(W_,71)*(DYNX(W_,143)-DYNX(W_,70)));
DYNX(W_,192) = DYNX(W_,186)*(1+DYNX(W_,188)*(DYNX(W_,149)-DYNX(W_,187)));
BoundParameterSection
InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,10) = 0;
DYNX(W_,16) = 0;
#endif
InitialSection
InitialStartSection
InitialStartSection2
DYNX(X_,3) = DYNX(W_,243);
DYNX(X_,4) = DYNX(W_,250);
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialSection
InitialSection2
DYNX(W_,201) = 0.0;
DYNX(X_,3) = DYNX(W_,243);
DYNX(X_,4) = DYNX(W_,250);
DYNX(W_,210) = DYNX(DP_,21)+(IF LessTime(DYNX(DP_,22), 0) THEN 0 ELSE IF 
  LessTime(DYNX(DP_,22)+DYNX(DP_,20), 1) THEN divGuarded((DYNTime-DYNX(DP_,22))*
  DYNX(DP_,19),"(time-speed_sp.startTime)*speed_sp.height",DYNX(DP_,20),
  "speed_sp.duration") ELSE DYNX(DP_,19));
DYNX(W_,218) = DYNX(W_,219)*DYNX(W_,210)+DYNX(DP_,36)*DYNX(X_,1);
DYNX(W_,220) = DYNX(DP_,37)*DYNX(W_,218);
DYNX(W_,237) = DYNX(W_,238)*DYNX(W_,210)+DYNX(DP_,45)*DYNX(X_,1);
DYNX(W_,224) = IF DYNX(W_,251) THEN 0 ELSE divGuarded(DYNX(W_,247)*(DYNX(W_,237)
  -DYNX(X_,4)),"PID.D.k*(PID.addD.y-PID.D.x)",DYNX(W_,248),"PID.D.T");
DYNX(W_,222) = DYNX(DP_,38)*DYNX(W_,220)+DYNX(DP_,39)*DYNX(W_,224)+DYNX(DP_,40)*
  DYNX(X_,3);
DYNX(W_,223) = DYNX(W_,221)*DYNX(W_,222);
DYNX(W_,229) = DYNX(DP_,42)*DYNX(W_,223)+DYNX(W_,232)*DYNX(DP_,41);
DYNX(W_,209) = homotopy(IF GreaterS(DYNX(W_,229),"PID.limiter.u", DYNX(W_,225),
  "PID.limiter.uMax", 0) THEN DYNX(W_,225) ELSE IF LessS(DYNX(W_,229),
  "PID.limiter.u", DYNX(W_,226),"PID.limiter.uMin", 1) THEN DYNX(W_,226) ELSE 
  DYNX(W_,229), DYNX(W_,229));
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection

DynamicsSection
DYNX(F_,2) = DYNX(X_,1);
DYNX(W_,169) = 0.0005*DYNX(X_,0);
DYNX(W_,11) = DYNX(W_,168)*DYNX(W_,169)*DYNX(X_,0);
if (NewParameters_) {
DYNX(DYNhelp,9) = divinvGuarded(DYNX(DP_,44),"load.w_nominal");
}
DYNX(DYNhelp,10) = fabs(DYNX(DYNhelp,9)*DYNX(X_,1));
DYNX(W_,208) = DYNX(DP_,43)*DYNX(DYNhelp,10);

 /* Linear system of equations to solve. */
/* Tag: simulation.linear[1] */
DYNX(F_,1) = RememberSimple_(DYNX(F_,1), 0);
SolveScalarLinearParametric(DYNX(W_,13)*DYNX(W_,207)*DYNX(W_,207)+DYNX(W_,203),
  "motor.motor.inertiaRotor.J*motor.idealGear.ratio*motor.idealGear.ratio+motor.inertia.J",
   DYNX(W_,207)*DYNX(W_,11)+DYNX(W_,208),"motor.idealGear.ratio*motor.motor.tauElectrical+motor.flange_b1.tau",
   DYNX(F_,1),"der(motor.inertia.w)");
DYNX(W_,17) = DYNX(W_,207)*DYNX(F_,1);
DYNX(W_,12) = DYNX(W_,11)-DYNX(W_,13)*DYNX(W_,17);
DYNX(W_,202) = DYNX(W_,203)*DYNX(F_,1)-DYNX(W_,208);
 /* End of Equation Block */ 

DYNX(W_,189) = DYNX(W_,192)*DYNX(X_,0);
DYNX(W_,72) = DYNX(W_,76)*DYNX(X_,0);
DYNX(W_,210) = DYNX(DP_,21)+(IF LessTime(DYNX(DP_,22), 0) THEN 0 ELSE IF 
  LessTime(DYNX(DP_,22)+DYNX(DP_,20), 1) THEN divGuarded((DYNTime-DYNX(DP_,22))*
  DYNX(DP_,19),"(time-speed_sp.startTime)*speed_sp.height",DYNX(DP_,20),
  "speed_sp.duration") ELSE DYNX(DP_,19));
DYNX(W_,218) = DYNX(W_,219)*DYNX(W_,210)+DYNX(DP_,36)*DYNX(X_,1);
DYNX(W_,220) = DYNX(DP_,37)*DYNX(W_,218);
DYNX(W_,237) = DYNX(W_,238)*DYNX(W_,210)+DYNX(DP_,45)*DYNX(X_,1);
DYNX(W_,224) = IF DYNX(W_,251) THEN 0 ELSE divGuarded(DYNX(W_,247)*(DYNX(W_,237)
  -DYNX(X_,4)),"PID.D.k*(PID.addD.y-PID.D.x)",DYNX(W_,248),"PID.D.T");
DYNX(W_,222) = DYNX(DP_,38)*DYNX(W_,220)+DYNX(DP_,39)*DYNX(W_,224)+DYNX(DP_,40)*
  DYNX(X_,3);
DYNX(W_,223) = DYNX(W_,221)*DYNX(W_,222);
DYNX(W_,229) = DYNX(DP_,42)*DYNX(W_,223)+DYNX(W_,232)*DYNX(DP_,41);
DYNX(W_,209) = IF GreaterS(DYNX(W_,229),"PID.limiter.u", DYNX(W_,225),
  "PID.limiter.uMax", 0) THEN DYNX(W_,225) ELSE IF LessS(DYNX(W_,229),
  "PID.limiter.u", DYNX(W_,226),"PID.limiter.uMin", 1) THEN DYNX(W_,226) ELSE 
  DYNX(W_,229);
DYNX(W_,73) =  -(DYNX(W_,72)+DYNX(W_,209));
BreakSectionFunctionCallNew(0);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(1);
DYNX(W_,16) = DYNX(W_,207)*DYNX(X_,1);
DYNX(W_,171) = DYNX(W_,168)*DYNX(W_,169)*DYNX(W_,16);

 /* Linear system of equations to solve. */
/* Tag: simulation.linear[2] */
DYNX(F_,0) = RememberSimple_(DYNX(F_,0), 1);
SolveScalarLinearParametric(0.0005+DYNX(W_,79),"0.0005+motor.motor.la.L",  -(
  DYNX(W_,189)-DYNX(W_,73)+DYNX(W_,171))," -(motor.motor.re.v-motor.motor.ra.n.v+motor.motor.airGapDC.vai)",
   DYNX(F_,0),"der(motor.motor.la.i)");
DYNX(W_,170) = 0.0005*DYNX(F_,0);
DYNX(W_,77) = DYNX(W_,79)*DYNX(F_,0);
 /* End of Equation Block */ 

DYNX(W_,253) = DYNX(DP_,50)*DYNX(W_,209)+DYNX(DP_,51)*DYNX(W_,229);
DYNX(W_,252) = DYNX(W_,254)*DYNX(W_,253);
DYNX(W_,244) = DYNX(DP_,47)*DYNX(W_,210)+DYNX(DP_,48)*DYNX(X_,1)+DYNX(DP_,49)*
  DYNX(W_,252);
DYNX(F_,3) = DYNX(W_,239)*DYNX(W_,244);
DYNX(F_,4) = IF DYNX(W_,251) THEN 0 ELSE divGuarded(DYNX(W_,237)-DYNX(X_,4),
  "PID.addD.y-PID.D.x",DYNX(W_,248),"PID.D.T");

AcceptedSection1

AcceptedSection2
DYNX(W_,15) = DYNX(W_,207)*DYNX(X_,2);
DYNX(W_,10) = DYNX(W_,15)-DYNX(DP_,10);
DYNX(W_,28) = DYNX(W_,15)-DYNX(DP_,10);
DYNX(W_,108) = DYNX(W_,15)-DYNX(DP_,10);
DYNX(W_,78) = DYNX(W_,73)-DYNX(W_,77);
DYNX(W_,68) = DYNX(W_,78)-DYNX(W_,171);
DYNX(W_,67) =  -(DYNX(W_,209)+DYNX(W_,68));
DYNX(W_,55) = DYNX(W_,67)*DYNX(X_,0);
DYNX(W_,56) = DYNX(W_,16)*DYNX(W_,12);
DYNX(W_,58) = DYNX(W_,13)*DYNX(W_,17)*DYNX(W_,16);
DYNX(W_,60) = DYNX(W_,72)*DYNX(X_,0);
DYNX(W_,88) = DYNX(W_,73)-DYNX(W_,68);
DYNX(W_,66) = DYNX(W_,189)*DYNX(X_,0);
DYNX(W_,59) = DYNX(W_,60)+DYNX(W_,66);
DYNX(W_,65) = DYNX(W_,68)*DYNX(X_,0);
DYNX(DYNhelp,11) = fabs(DYNX(W_,16));
DYNX(W_,104) = RealBmax(DYNX(DYNhelp,11), 0.00014765485471872027);
DYNX(W_,148) = DYNX(W_,60)+DYNX(W_,66);
DYNX(W_,211) = DYNX(W_,210)-DYNX(X_,1);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareParameter("motor.motor.TaOperational", "Operational armature temperature [K|degC]",\
 0, 293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("motor.motor.VaNominal", "Nominal armature voltage [V]", 1, 100,\
 0.0,0.0,0.0,0,560)
DeclareParameter("motor.motor.IaNominal", "Nominal armature current (>0..Motor, <0..Generator) [A]",\
 2, 100, 0.0,0.0,0.0,0,560)
DeclareVariable("motor.motor.wNominal", "Nominal speed [rad/s|rev/min]", \
147.6548547187203, 0.0,0.0,0.0,0,513)
DeclareParameter("motor.motor.TaNominal", "Nominal armature temperature [K|degC]",\
 3, 293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("motor.motor.Ra", "Armature resistance at TaRef [Ohm]", 4, 0.05,\
 0.0,0.0,0.0,0,560)
DeclareParameter("motor.motor.TaRef", "Reference temperature of armature resistance [K|degC]",\
 5, 293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("motor.motor.alpha20a", "Temperature coefficient of armature resistance [1/K]",\
 6, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("motor.motor.La", "Armature inductance [H]", 7, 0.0015, \
0.0,0.0,0.0,0,560)
DeclareParameter("motor.motor.Jr", "Rotor's moment of inertia [kg.m2]", 8, 0.15,\
 0.0,0.0,0.0,0,560)
DeclareVariable("motor.motor.useSupport", "Enable / disable (=fixed stator) support [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("motor.motor.Js", "Stator's moment of inertia [kg.m2]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.useThermalPort", "Enable / disable (=fixed temperatures) thermal port [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("motor.motor.frictionParameters.PRef", "Reference friction losses at wRef [W]",\
 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("motor.motor.frictionParameters.wRef", "Reference angular velocity that the PRef refer to [rad/s|rev/min]",\
 147.6548547187203, 1E-60,1E+100,0.0,0,513)
DeclareParameter("motor.motor.frictionParameters.power_w", "Exponent of friction torque w.r.t. angular velocity",\
 9, 2, 1E-60,1E+100,0.0,0,560)
DeclareVariable("motor.motor.frictionParameters.tauRef", "Reference friction torque at reference angular velocity [N.m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.frictionParameters.linear", "Linear angular velocity range with respect to reference angular velocity [1]",\
 0.001, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.frictionParameters.wLinear", "Linear angular velocity range [rad/s]",\
 0.14765485471872028, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.frictionParameters.tauLinear", "Torque corresponding with linear angular velocity range [N.m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.phiMechanical", "Mechanical angle of rotor against stator [rad|deg]",\
 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("motor.motor.der(phiMechanical)", "der(Mechanical angle of rotor against stator) [rad/s]",\
 "motor.motor.inertiaRotor.w", 1, 5, 16, 0)
DeclareAlias2("motor.motor.wMechanical", "Mechanical angular velocity of rotor against stator [rad/s|rev/min]",\
 "motor.motor.inertiaRotor.w", 1, 5, 16, 0)
DeclareVariable("motor.motor.tauElectrical", "Electromagnetic torque [N.m]", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareVariable("motor.motor.tauShaft", "Shaft torque [N.m]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("motor.motor.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "motor.motor.inertiaRotor.phi", 1, 5, 15, 4)
DeclareAlias2("motor.motor.flange.tau", "Cut torque in the flange [N.m]", \
"motor.motor.tauShaft", -1, 5, 12, 132)
DeclareAlias2("motor.motor.inertiaRotor.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "motor.motor.inertiaRotor.phi", 1, 5, 15, 4)
DeclareAlias2("motor.motor.inertiaRotor.flange_a.tau", "Cut torque in the flange [N.m]",\
 "motor.motor.tauElectrical", 1, 5, 11, 132)
DeclareAlias2("motor.motor.inertiaRotor.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "motor.motor.inertiaRotor.phi", 1, 5, 15, 4)
DeclareAlias2("motor.motor.inertiaRotor.flange_b.tau", "Cut torque in the flange [N.m]",\
 "motor.motor.tauShaft", -1, 5, 12, 132)
DeclareVariable("motor.motor.inertiaRotor.J", "Moment of inertia [kg.m2]", 1, \
0.0,1E+100,0.0,0,513)
DeclareVariable("motor.motor.inertiaRotor.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 3, 1.0,5.0,0.0,0,1541)
DeclareVariable("motor.motor.inertiaRotor.phi", "Absolute rotation angle of component [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("motor.motor.inertiaRotor.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 "motor.motor.inertiaRotor.w", 1, 5, 16, 0)
DeclareVariable("motor.motor.inertiaRotor.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("motor.motor.inertiaRotor.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("motor.motor.inertiaRotor.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "motor.motor.inertiaRotor.der(w)", 1, 5, 17, 0)
DeclareAlias2("motor.motor.inertiaStator.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "motor.motor.fixed.phi0", 1, 7, 10, 4)
DeclareVariable("motor.motor.inertiaStator.flange_a.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("motor.motor.inertiaStator.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "motor.motor.fixed.phi0", 1, 7, 10, 4)
DeclareVariable("motor.motor.inertiaStator.flange_b.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("motor.motor.inertiaStator.J", "Moment of inertia [kg.m2]", 1, \
0.0,1E+100,0.0,0,513)
DeclareVariable("motor.motor.inertiaStator.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 3, 1.0,5.0,0.0,0,1541)
DeclareAlias2("motor.motor.inertiaStator.phi", "Absolute rotation angle of component [rad|deg]",\
 "motor.motor.fixed.phi0", 1, 7, 10, 0)
DeclareVariable("motor.motor.inertiaStator.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.inertiaStator.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.inertiaStator.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.inertiaStator.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("motor.motor.fixed.phi0", "Fixed offset angle of housing [rad|deg]",\
 10, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("motor.motor.fixed.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "motor.motor.fixed.phi0", 1, 7, 10, 4)
DeclareAlias2("motor.motor.fixed.flange.tau", "Cut torque in the flange [N.m]", \
"motor.motor.tauElectrical", -1, 5, 11, 132)
DeclareAlias2("motor.motor.friction.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "motor.motor.inertiaRotor.phi", 1, 5, 15, 4)
DeclareVariable("motor.motor.friction.flange.tau", "Cut torque in the flange [N.m]",\
 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("motor.motor.friction.support.phi", "Absolute rotation angle of flange [rad|deg]",\
 "motor.motor.fixed.phi0", 1, 7, 10, 4)
DeclareVariable("motor.motor.friction.support.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("motor.motor.friction.phi", "Angle between shaft and support [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("motor.motor.friction.der(phi)", "der(Angle between shaft and support) [rad/s]",\
 "motor.motor.inertiaRotor.w", 1, 5, 16, 0)
DeclareVariable("motor.motor.friction.tau", "Torque [N.m]", 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("motor.motor.friction.w", "Relative angular velocity of flange and support [rad/s]",\
 "motor.motor.inertiaRotor.w", 1, 5, 16, 0)
DeclareVariable("motor.motor.friction.frictionParameters.PRef", "Reference friction losses at wRef [W]",\
 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("motor.motor.friction.frictionParameters.wRef", "Reference angular velocity that the PRef refer to [rad/s|rev/min]",\
 147.6548547187203, 1E-60,1E+100,0.0,0,513)
DeclareVariable("motor.motor.friction.frictionParameters.power_w", \
"Exponent of friction torque w.r.t. angular velocity", 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("motor.motor.friction.frictionParameters.tauRef", \
"Reference friction torque at reference angular velocity [N.m]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("motor.motor.friction.frictionParameters.linear", \
"Linear angular velocity range with respect to reference angular velocity", \
0.001, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.friction.frictionParameters.wLinear", \
"Linear angular velocity range [rad/s]", 0.14765485471872028, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.friction.frictionParameters.tauLinear", \
"Torque corresponding with linear angular velocity range [N.m]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("motor.motor.friction.useHeatPort", "= true, if heatPort is enabled [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("motor.motor.friction.heatPort.T", "Port temperature [K|degC]", \
293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("motor.motor.friction.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("motor.motor.friction.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("motor.motor.internalSupport.phi", "Absolute rotation angle of flange [rad|deg]",\
 "motor.motor.fixed.phi0", 1, 7, 10, 1028)
DeclareVariable("motor.motor.internalSupport.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,2825)
DeclareVariable("motor.motor.coreParameters.m", "Number of phases (1 for DC, 3 for induction machines) [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,517)
DeclareVariable("motor.motor.coreParameters.PRef", "Reference core losses at reference inner voltage VRef [W]",\
 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("motor.motor.coreParameters.VRef", "Reference inner RMS voltage that reference core losses PRef refer to [V]",\
 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("motor.motor.coreParameters.wRef", "Reference angular velocity that reference core losses PRef refer to [rad/s]",\
 147.6548547187203, 1E-60,1E+100,0.0,0,513)
DeclareVariable("motor.motor.coreParameters.ratioHysteresis", "Ratio of hysteresis losses with respect to the total core losses at VRef and fRef",\
 0, 0.0,1.0,0.0,0,513)
DeclareVariable("motor.motor.coreParameters.GcRef", "Reference conductance at reference frequency and voltage [S]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.coreParameters.wMin", "Angular velocity limit [rad/s]",\
 0.00014765485471872027, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.strayLoadParameters.PRef", "Reference stray load losses at IRef and wRef [W]",\
 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("motor.motor.strayLoadParameters.IRef", "Reference RMS current that PRef refers to [A]",\
 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("motor.motor.strayLoadParameters.wRef", "Reference angular velocity that PRef refers to [rad/s|rev/min]",\
 147.6548547187203, 1E-60,1E+100,0.0,0,513)
DeclareParameter("motor.motor.strayLoadParameters.power_w", "Exponent of stray load loss torque w.r.t. angular velocity",\
 11, 1, 1E-60,1E+100,0.0,0,560)
DeclareVariable("motor.motor.strayLoadParameters.tauRef", "Reference stray load torque at reference angular velocity and reference current [N.m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.brushParameters.V", "Total voltage drop of brushes for currents > ILinear [V]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.brushParameters.ILinear", "Current indicating linear voltage region of brush voltage drop [A]",\
 0.01, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.powerBalance.powerArmature", "Electrical armature power [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("motor.motor.powerBalance.powerMechanical", "Mechanical power [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("motor.motor.powerBalance.powerInertiaStator", "Stator inertia power [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.powerBalance.powerInertiaRotor", "Rotor inertia power [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("motor.motor.powerBalance.lossPowerTotal", "Total loss power [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("motor.motor.powerBalance.lossPowerArmature", "Armature copper losses [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("motor.motor.powerBalance.lossPowerCore", "Core losses [W]", 0.0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.powerBalance.lossPowerStrayLoad", "Stray load losses [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.powerBalance.lossPowerFriction", "Friction losses [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.powerBalance.lossPowerBrush", "Brush losses [W]", \
0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.powerBalance.powerSeriesExcitation", \
"Electrical series excitation power [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("motor.motor.powerBalance.lossPowerSeriesExcitation", \
"Series excitation losses [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("motor.motor.va", "Armature voltage [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("motor.motor.ia", "Armature current [A]", "motor.motor.la.i", 1, 1,\
 0, 0)
DeclareAlias2("motor.motor.pin_ap.v", "Potential at the pin [V]", "motor.v1", -1,\
 5, 209, 4)
DeclareAlias2("motor.motor.pin_ap.i", "Current flowing into the pin [A]", \
"motor.motor.la.i", 1, 1, 0, 132)
DeclareVariable("motor.motor.pin_an.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,520)
DeclareAlias2("motor.motor.pin_an.i", "Current flowing into the pin [A]", \
"motor.motor.la.i", -1, 1, 0, 132)
DeclareVariable("motor.motor.ra.R", "Resistance at temperature T_ref [Ohm]", 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.ra.T_ref", "Reference temperature [K|degC]", 288.15,\
 0.0,1E+100,300.0,0,513)
DeclareVariable("motor.motor.ra.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.ra.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("motor.motor.ra.p.v", "Potential at the pin [V]", "motor.v1", -1, 5,\
 209, 4)
DeclareAlias2("motor.motor.ra.p.i", "Current flowing into the pin [A]", \
"motor.motor.la.i", 1, 1, 0, 132)
DeclareVariable("motor.motor.ra.n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,\
0.0,0,520)
DeclareAlias2("motor.motor.ra.n.i", "Current flowing into the pin [A]", \
"motor.motor.la.i", -1, 1, 0, 132)
DeclareAlias2("motor.motor.ra.i", "Current flowing from pin p to pin n [A]", \
"motor.motor.la.i", 1, 1, 0, 0)
DeclareVariable("motor.motor.ra.useHeatPort", "= true, if heatPort is enabled [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("motor.motor.ra.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("motor.motor.ra.heatPort.T", "Port temperature [K|degC]", \
"motor.motor.thermalAmbient.constTa.k", 1, 5, 143, 4)
DeclareAlias2("motor.motor.ra.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "motor.motor.powerBalance.lossPowerArmature", -1, 5, 60, 132)
DeclareAlias2("motor.motor.ra.LossPower", "Loss power leaving component via heatPort [W]",\
 "motor.motor.powerBalance.lossPowerArmature", 1, 5, 60, 0)
DeclareAlias2("motor.motor.ra.T_heatPort", "Temperature of heatPort [K|degC]", \
"motor.motor.thermalAmbient.constTa.k", 1, 5, 143, 0)
DeclareVariable("motor.motor.ra.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.la.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("motor.motor.la.p.v", "Potential at the pin [V]", "motor.motor.ra.n.v", 1,\
 5, 73, 4)
DeclareAlias2("motor.motor.la.p.i", "Current flowing into the pin [A]", \
"motor.motor.la.i", 1, 1, 0, 132)
DeclareVariable("motor.motor.la.n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,\
0.0,0,520)
DeclareAlias2("motor.motor.la.n.i", "Current flowing into the pin [A]", \
"motor.motor.la.i", -1, 1, 0, 132)
DeclareState("motor.motor.la.i", "Current flowing from pin p to pin n [A]", 0, 0,\
 0.0,0.0,0.0,0,560)
DeclareDerivative("motor.motor.la.der(i)", "der(Current flowing from pin p to pin n) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("motor.motor.la.L", "Inductance [H]", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.la.quasiStatic", "No electrical transients if true [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("motor.motor.brush.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0, 0.0,0.0,0.0,0,513)
DeclareAlias2("motor.motor.brush.p.v", "Potential at the pin [V]", \
"motor.motor.pin_an.v", 1, 5, 68, 4)
DeclareAlias2("motor.motor.brush.p.i", "Current flowing into the pin [A]", \
"motor.motor.la.i", 1, 1, 0, 132)
DeclareAlias2("motor.motor.brush.n.v", "Potential at the pin [V]", \
"motor.motor.pin_an.v", 1, 5, 68, 4)
DeclareAlias2("motor.motor.brush.n.i", "Current flowing into the pin [A]", \
"motor.motor.la.i", -1, 1, 0, 132)
DeclareAlias2("motor.motor.brush.i", "Current flowing from pin p to pin n [A]", \
"motor.motor.la.i", 1, 1, 0, 0)
DeclareVariable("motor.motor.brush.brushParameters.V", "Total voltage drop of brushes for currents > ILinear [V]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.brush.brushParameters.ILinear", "Current indicating linear voltage region of brush voltage drop [A]",\
 0.01, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.brush.useHeatPort", "= true, if heatPort is enabled [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("motor.motor.brush.heatPort.T", "Port temperature [K|degC]", \
293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("motor.motor.brush.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("motor.motor.brush.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.core.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("motor.motor.core.p.v", "Potential at the pin [V]", \
"motor.motor.ra.n.v", 1, 5, 73, 4)
DeclareVariable("motor.motor.core.p.i", "Current flowing into the pin [A]", 0, \
0.0,0.0,0.0,0,777)
DeclareAlias2("motor.motor.core.n.v", "Potential at the pin [V]", \
"motor.motor.pin_an.v", 1, 5, 68, 4)
DeclareVariable("motor.motor.core.n.i", "Current flowing into the pin [A]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("motor.motor.core.i", "Current flowing from pin p to pin n [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.core.coreParameters.m", "Number of phases (1 for DC, 3 for induction machines) [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,517)
DeclareVariable("motor.motor.core.coreParameters.PRef", "Reference core losses at reference inner voltage VRef [W]",\
 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("motor.motor.core.coreParameters.VRef", "Reference inner RMS voltage that reference core losses PRef refer to [V]",\
 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("motor.motor.core.coreParameters.wRef", "Reference angular velocity that reference core losses PRef refer to [rad/s]",\
 147.6548547187203, 1E-60,1E+100,0.0,0,513)
DeclareVariable("motor.motor.core.coreParameters.ratioHysteresis", \
"Ratio of hysteresis losses with respect to the total core losses at VRef and fRef",\
 0.0, 0.0,1.0,0.0,0,513)
DeclareVariable("motor.motor.core.coreParameters.GcRef", "Reference conductance at reference frequency and voltage [S]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.core.coreParameters.wMin", "Angular velocity limit [rad/s]",\
 0.00014765485471872027, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.core.useHeatPort", "= true, if heatPort is enabled [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("motor.motor.core.heatPort.T", "Port temperature [K|degC]", \
293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("motor.motor.core.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("motor.motor.core.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("motor.motor.core.w", "Remagnetization angular velocity [rad/s]", \
"motor.motor.inertiaRotor.w", 1, 5, 16, 0)
DeclareVariable("motor.motor.core.Gc", "Variable core loss conductance [S]", 0, \
0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.core.wLimit", "Limited angular velocity [rad/s]", \
0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("motor.motor.strayLoad.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0, 0.0,0.0,0.0,0,513)
DeclareAlias2("motor.motor.strayLoad.p.v", "Potential at the pin [V]", \
"motor.v1", -1, 5, 209, 4)
DeclareAlias2("motor.motor.strayLoad.p.i", "Current flowing into the pin [A]", \
"motor.motor.la.i", 1, 1, 0, 132)
DeclareAlias2("motor.motor.strayLoad.n.v", "Potential at the pin [V]", \
"motor.v1", -1, 5, 209, 4)
DeclareAlias2("motor.motor.strayLoad.n.i", "Current flowing into the pin [A]", \
"motor.motor.la.i", -1, 1, 0, 132)
DeclareAlias2("motor.motor.strayLoad.i", "Current flowing from pin p to pin n [A]",\
 "motor.motor.la.i", 1, 1, 0, 0)
DeclareAlias2("motor.motor.strayLoad.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "motor.motor.inertiaRotor.phi", 1, 5, 15, 4)
DeclareVariable("motor.motor.strayLoad.flange.tau", "Cut torque in the flange [N.m]",\
 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("motor.motor.strayLoad.support.phi", "Absolute rotation angle of flange [rad|deg]",\
 "motor.motor.fixed.phi0", 1, 7, 10, 4)
DeclareVariable("motor.motor.strayLoad.support.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("motor.motor.strayLoad.phi", "Angle between shaft and support [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("motor.motor.strayLoad.der(phi)", "der(Angle between shaft and support) [rad/s]",\
 "motor.motor.inertiaRotor.w", 1, 5, 16, 0)
DeclareVariable("motor.motor.strayLoad.tau", "Torque [N.m]", 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("motor.motor.strayLoad.w", "Relative angular velocity of flange and support [rad/s]",\
 "motor.motor.inertiaRotor.w", 1, 5, 16, 0)
DeclareVariable("motor.motor.strayLoad.strayLoadParameters.PRef", \
"Reference stray load losses at IRef and wRef [W]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("motor.motor.strayLoad.strayLoadParameters.IRef", \
"Reference RMS current that PRef refers to [A]", 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("motor.motor.strayLoad.strayLoadParameters.wRef", \
"Reference angular velocity that PRef refers to [rad/s|rev/min]", \
147.6548547187203, 1E-60,1E+100,0.0,0,513)
DeclareVariable("motor.motor.strayLoad.strayLoadParameters.power_w", \
"Exponent of stray load loss torque w.r.t. angular velocity", 1E-60, 1E-60,\
1E+100,0.0,0,513)
DeclareVariable("motor.motor.strayLoad.strayLoadParameters.tauRef", \
"Reference stray load torque at reference angular velocity and reference current [N.m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.strayLoad.useHeatPort", "= true, if heatPort is enabled [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("motor.motor.strayLoad.heatPort.T", "Port temperature [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("motor.motor.strayLoad.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("motor.motor.strayLoad.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.thermalAmbient.useTemperatureInputs", \
"If true, temperature inputs are used; else, temperatures are constant [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("motor.motor.thermalAmbient.TDefault", "Default temperature [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("motor.motor.thermalAmbient.Ta", "Temperature of armature [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("motor.motor.thermalAmbient.Q_flowArmature", "Heat flow rate of armature [W]",\
 "motor.motor.powerBalance.lossPowerArmature", 1, 5, 60, 0)
DeclareVariable("motor.motor.thermalAmbient.Q_flowCore", "Heat flow rate of core losses [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.thermalAmbient.Q_flowStrayLoad", "Heat flow rate of stray load losses [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.thermalAmbient.Q_flowFriction", "Heat flow rate of friction losses [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.thermalAmbient.Q_flowBrush", "Heat flow rate of brushes [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("motor.motor.thermalAmbient.thermalPort.heatPortArmature.T", \
"Port temperature [K|degC]", "motor.motor.thermalAmbient.constTa.k", 1, 5, 143, 4)
DeclareAlias2("motor.motor.thermalAmbient.thermalPort.heatPortArmature.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"motor.motor.powerBalance.lossPowerArmature", 1, 5, 60, 132)
DeclareVariable("motor.motor.thermalAmbient.thermalPort.heatPortCore.T", \
"Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("motor.motor.thermalAmbient.thermalPort.heatPortCore.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("motor.motor.thermalAmbient.thermalPort.heatPortStrayLoad.T", \
"Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("motor.motor.thermalAmbient.thermalPort.heatPortStrayLoad.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("motor.motor.thermalAmbient.thermalPort.heatPortFriction.T", \
"Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("motor.motor.thermalAmbient.thermalPort.heatPortFriction.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("motor.motor.thermalAmbient.thermalPort.heatPortBrush.T", \
"Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("motor.motor.thermalAmbient.thermalPort.heatPortBrush.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareAlias2("motor.motor.thermalAmbient.thermalPort.heatPortSeriesExcitation.T",\
 "Port temperature [K|degC]", "motor.motor.thermalAmbient.constTse.k", 1, 5, 149,\
 4)
DeclareAlias2("motor.motor.thermalAmbient.thermalPort.heatPortSeriesExcitation.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"motor.motor.powerBalance.lossPowerSeriesExcitation", 1, 5, 66, 132)
DeclareAlias2("motor.motor.thermalAmbient.temperatureArmature.port.T", \
"Port temperature [K|degC]", "motor.motor.thermalAmbient.constTa.k", 1, 5, 143, 4)
DeclareAlias2("motor.motor.thermalAmbient.temperatureArmature.port.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"motor.motor.powerBalance.lossPowerArmature", 1, 5, 60, 132)
DeclareAlias2("motor.motor.thermalAmbient.temperatureArmature.T", "[K]", \
"motor.motor.thermalAmbient.constTa.k", 1, 5, 143, 0)
DeclareVariable("motor.motor.thermalAmbient.temperatureCore.T", "Fixed temperature at port [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("motor.motor.thermalAmbient.temperatureCore.port.T", \
"Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("motor.motor.thermalAmbient.temperatureCore.port.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("motor.motor.thermalAmbient.temperatureStrayLoad.T", \
"Fixed temperature at port [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("motor.motor.thermalAmbient.temperatureStrayLoad.port.T", \
"Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("motor.motor.thermalAmbient.temperatureStrayLoad.port.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("motor.motor.thermalAmbient.temperatureFriction.T", \
"Fixed temperature at port [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("motor.motor.thermalAmbient.temperatureFriction.port.T", \
"Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("motor.motor.thermalAmbient.temperatureFriction.port.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("motor.motor.thermalAmbient.constTa.k", "Constant output value [K]",\
 1, 0.0,1E+100,300.0,0,513)
DeclareAlias2("motor.motor.thermalAmbient.constTa.y", "Connector of Real output signal [K]",\
 "motor.motor.thermalAmbient.constTa.k", 1, 5, 143, 0)
DeclareVariable("motor.motor.thermalAmbient.temperatureBrush.T", \
"Fixed temperature at port [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("motor.motor.thermalAmbient.temperatureBrush.port.T", \
"Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("motor.motor.thermalAmbient.temperatureBrush.port.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("motor.motor.thermalAmbient.Tse", "Temperature of series excitation [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("motor.motor.thermalAmbient.Q_flowSeriesExcitation", \
"Heat flow rate of series excitation [W]", "motor.motor.powerBalance.lossPowerSeriesExcitation", 1,\
 5, 66, 0)
DeclareVariable("motor.motor.thermalAmbient.Q_flowTotal", "[W]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareAlias2("motor.motor.thermalAmbient.temperatureSeriesExcitation.port.T", \
"Port temperature [K|degC]", "motor.motor.thermalAmbient.constTse.k", 1, 5, 149,\
 4)
DeclareAlias2("motor.motor.thermalAmbient.temperatureSeriesExcitation.port.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"motor.motor.powerBalance.lossPowerSeriesExcitation", 1, 5, 66, 132)
DeclareAlias2("motor.motor.thermalAmbient.temperatureSeriesExcitation.T", "[K]",\
 "motor.motor.thermalAmbient.constTse.k", 1, 5, 149, 0)
DeclareVariable("motor.motor.thermalAmbient.constTse.k", "Constant output value [K]",\
 1, 0.0,1E+100,300.0,0,513)
DeclareAlias2("motor.motor.thermalAmbient.constTse.y", "Connector of Real output signal [K]",\
 "motor.motor.thermalAmbient.constTse.k", 1, 5, 149, 0)
DeclareVariable("motor.motor.pi", "", 3.141592653589793, 0.0,0.0,0.0,0,2561)
DeclareVariable("motor.motor.quasiStatic", "No electrical transients if true [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("motor.motor.ViNominal", "Nominal induced Voltage [V]", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("motor.motor.psi_eNominal", "Nominal magnetic flux [Wb]", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("motor.motor.turnsRatio", "Ratio of armature turns over number of turns of the excitation winding [rad-1]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("motor.motor.internalThermalPort.heatPortArmature.T", \
"Port temperature [K|degC]", "motor.motor.thermalAmbient.constTa.k", 1, 5, 143, 1028)
DeclareVariable("motor.motor.internalThermalPort.heatPortArmature.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareVariable("motor.motor.internalThermalPort.heatPortCore.T", \
"Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,2569)
DeclareVariable("motor.motor.internalThermalPort.heatPortCore.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareVariable("motor.motor.internalThermalPort.heatPortStrayLoad.T", \
"Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,2569)
DeclareVariable("motor.motor.internalThermalPort.heatPortStrayLoad.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareVariable("motor.motor.internalThermalPort.heatPortFriction.T", \
"Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,2569)
DeclareVariable("motor.motor.internalThermalPort.heatPortFriction.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareVariable("motor.motor.internalThermalPort.heatPortBrush.T", \
"Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,2569)
DeclareVariable("motor.motor.internalThermalPort.heatPortBrush.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareAlias2("motor.motor.internalThermalPort.heatPortSeriesExcitation.T", \
"Port temperature [K|degC]", "motor.motor.thermalAmbient.constTse.k", 1, 5, 149,\
 1028)
DeclareVariable("motor.motor.internalThermalPort.heatPortSeriesExcitation.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareParameter("motor.motor.Re", "Series excitation resistance at TeRef [Ohm]",\
 12, 0.01, 0.0,0.0,0.0,0,560)
DeclareParameter("motor.motor.TeRef", "Reference temperature of excitation resistance [K|degC]",\
 13, 293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("motor.motor.alpha20e", "Temperature coefficient of excitation resistance [1/K]",\
 14, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("motor.motor.Le", "Total field excitation inductance [H]", \
0.0005, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.sigmae", "Stray fraction of total excitation inductance [1]",\
 0, 0.0,0.99,0.0,0,513)
DeclareParameter("motor.motor.TeNominal", "Nominal series excitation temperature [K|degC]",\
 15, 293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("motor.motor.TeOperational", "Operational series excitation temperature [K|degC]",\
 16, 293.15, 0.0,1E+100,300.0,0,560)
DeclareAlias2("motor.motor.ve", "Field excitation voltage [V]", "motor.motor.pin_an.v", 1,\
 5, 68, 0)
DeclareAlias2("motor.motor.ie", "Field excitation current [A]", "motor.motor.la.i", 1,\
 1, 0, 0)
DeclareVariable("motor.motor.airGapDC.quasiStatic", "No electrical transients if true [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("motor.motor.airGapDC.turnsRatio", "Ratio of armature turns over number of turns of the excitation winding [rad-1]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("motor.motor.airGapDC.w", "Angular velocity [rad/s]", \
"motor.motor.inertiaRotor.w", 1, 5, 16, 0)
DeclareAlias2("motor.motor.airGapDC.vei", "Voltage drop across field excitation inductance [V]",\
 "motor.motor.airGapDC.der(psi_e)", 1, 5, 170, 0)
DeclareAlias2("motor.motor.airGapDC.ie", "Excitation current [A]", \
"motor.motor.la.i", 1, 1, 0, 0)
DeclareVariable("motor.motor.airGapDC.psi_e", "Excitation flux [Wb]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("motor.motor.airGapDC.der(psi_e)", "der(Excitation flux) [V]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("motor.motor.airGapDC.vai", "Induced armature voltage [V]", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareAlias2("motor.motor.airGapDC.ia", "Armature current [A]", \
"motor.motor.la.i", 1, 1, 0, 0)
DeclareAlias2("motor.motor.airGapDC.tauElectrical", "[N.m]", "motor.motor.tauElectrical", 1,\
 5, 11, 0)
DeclareAlias2("motor.motor.airGapDC.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "motor.motor.inertiaRotor.phi", 1, 5, 15, 4)
DeclareAlias2("motor.motor.airGapDC.flange.der(phi)", "der(Absolute rotation angle of flange) [rad/s]",\
 "motor.motor.inertiaRotor.w", 1, 5, 16, 4)
DeclareAlias2("motor.motor.airGapDC.flange.tau", "Cut torque in the flange [N.m]",\
 "motor.motor.tauElectrical", -1, 5, 11, 132)
DeclareAlias2("motor.motor.airGapDC.support.phi", "Absolute rotation angle of flange [rad|deg]",\
 "motor.motor.fixed.phi0", 1, 7, 10, 4)
DeclareVariable("motor.motor.airGapDC.support.der(phi)", "der(Absolute rotation angle of flange) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("motor.motor.airGapDC.support.tau", "Cut torque in the flange [N.m]",\
 "motor.motor.tauElectrical", 1, 5, 11, 132)
DeclareAlias2("motor.motor.airGapDC.pin_ap.v", "Potential at the pin [V]", \
"motor.motor.la.n.v", 1, 5, 78, 4)
DeclareAlias2("motor.motor.airGapDC.pin_ap.i", "Current flowing into the pin [A]",\
 "motor.motor.la.i", 1, 1, 0, 132)
DeclareAlias2("motor.motor.airGapDC.pin_ep.v", "Potential at the pin [V]", \
"motor.motor.airGapDC.der(psi_e)", 1, 5, 170, 4)
DeclareAlias2("motor.motor.airGapDC.pin_ep.i", "Current flowing into the pin [A]",\
 "motor.motor.la.i", 1, 1, 0, 132)
DeclareAlias2("motor.motor.airGapDC.pin_an.v", "Potential at the pin [V]", \
"motor.motor.pin_an.v", 1, 5, 68, 4)
DeclareAlias2("motor.motor.airGapDC.pin_an.i", "Current flowing into the pin [A]",\
 "motor.motor.la.i", -1, 1, 0, 132)
DeclareVariable("motor.motor.airGapDC.pin_en.v", "Potential at the pin [V]", 0, \
0.0,0.0,0.0,0,521)
DeclareAlias2("motor.motor.airGapDC.pin_en.i", "Current flowing into the pin [A]",\
 "motor.motor.la.i", -1, 1, 0, 132)
DeclareVariable("motor.motor.airGapDC.Le", "Excitation inductance [H]", 0.0005, \
0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.compoundDCExcitation.excitationTurnsRatio", \
"Ratio of series excitation turns over shunt excitation turns [1]", 1, 0.0,0.0,\
0.0,0,513)
DeclareAlias2("motor.motor.compoundDCExcitation.v", "[V]", "motor.motor.airGapDC.der(psi_e)", 1,\
 5, 170, 0)
DeclareAlias2("motor.motor.compoundDCExcitation.i", "[A]", "motor.motor.la.i", -1,\
 1, 0, 0)
DeclareAlias2("motor.motor.compoundDCExcitation.ve", "[V]", "motor.motor.airGapDC.der(psi_e)", 1,\
 5, 170, 0)
DeclareVariable("motor.motor.compoundDCExcitation.ie", "[A]", 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("motor.motor.compoundDCExcitation.vse", "[V]", "motor.motor.airGapDC.der(psi_e)", 1,\
 5, 170, 0)
DeclareAlias2("motor.motor.compoundDCExcitation.ise", "[A]", "motor.motor.la.i", 1,\
 1, 0, 0)
DeclareAlias2("motor.motor.compoundDCExcitation.pin_p.v", "Potential at the pin [V]",\
 "motor.motor.airGapDC.der(psi_e)", 1, 5, 170, 4)
DeclareAlias2("motor.motor.compoundDCExcitation.pin_p.i", "Current flowing into the pin [A]",\
 "motor.motor.la.i", -1, 1, 0, 132)
DeclareVariable("motor.motor.compoundDCExcitation.pin_n.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("motor.motor.compoundDCExcitation.pin_n.i", "Current flowing into the pin [A]",\
 "motor.motor.la.i", 1, 1, 0, 132)
DeclareAlias2("motor.motor.compoundDCExcitation.pin_ep.v", "Potential at the pin [V]",\
 "motor.motor.airGapDC.der(psi_e)", 1, 5, 170, 4)
DeclareVariable("motor.motor.compoundDCExcitation.pin_ep.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("motor.motor.compoundDCExcitation.pin_en.v", "Potential at the pin [V]",\
 0, 0.0,0.0,0.0,0,521)
DeclareVariable("motor.motor.compoundDCExcitation.pin_en.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("motor.motor.compoundDCExcitation.pin_sep.v", "Potential at the pin [V]",\
 "motor.motor.airGapDC.der(psi_e)", 1, 5, 170, 4)
DeclareAlias2("motor.motor.compoundDCExcitation.pin_sep.i", "Current flowing into the pin [A]",\
 "motor.motor.la.i", 1, 1, 0, 132)
DeclareVariable("motor.motor.compoundDCExcitation.pin_sen.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("motor.motor.compoundDCExcitation.pin_sen.i", "Current flowing into the pin [A]",\
 "motor.motor.la.i", -1, 1, 0, 132)
DeclareVariable("motor.motor.ground.p.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,521)
DeclareVariable("motor.motor.ground.p.i", "Current flowing into the pin [A]", \
0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("motor.motor.groundE.p.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,521)
DeclareVariable("motor.motor.groundE.p.i", "Current flowing into the pin [A]", \
0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("motor.motor.re.R", "Resistance at temperature T_ref [Ohm]", 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.re.T_ref", "Reference temperature [K|degC]", 288.15,\
 0.0,1E+100,300.0,0,513)
DeclareVariable("motor.motor.re.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.re.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("motor.motor.re.p.v", "Potential at the pin [V]", "motor.motor.pin_an.v", 1,\
 5, 68, 4)
DeclareAlias2("motor.motor.re.p.i", "Current flowing into the pin [A]", \
"motor.motor.la.i", 1, 1, 0, 132)
DeclareAlias2("motor.motor.re.n.v", "Potential at the pin [V]", "motor.motor.airGapDC.der(psi_e)", 1,\
 5, 170, 4)
DeclareAlias2("motor.motor.re.n.i", "Current flowing into the pin [A]", \
"motor.motor.la.i", -1, 1, 0, 132)
DeclareAlias2("motor.motor.re.i", "Current flowing from pin p to pin n [A]", \
"motor.motor.la.i", 1, 1, 0, 0)
DeclareVariable("motor.motor.re.useHeatPort", "= true, if heatPort is enabled [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("motor.motor.re.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("motor.motor.re.heatPort.T", "Port temperature [K|degC]", \
"motor.motor.thermalAmbient.constTse.k", 1, 5, 149, 4)
DeclareAlias2("motor.motor.re.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "motor.motor.powerBalance.lossPowerSeriesExcitation", -1, 5, 66, 132)
DeclareAlias2("motor.motor.re.LossPower", "Loss power leaving component via heatPort [W]",\
 "motor.motor.powerBalance.lossPowerSeriesExcitation", 1, 5, 66, 0)
DeclareAlias2("motor.motor.re.T_heatPort", "Temperature of heatPort [K|degC]", \
"motor.motor.thermalAmbient.constTse.k", 1, 5, 149, 0)
DeclareVariable("motor.motor.re.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.lesigma.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("motor.motor.lesigma.p.v", "Potential at the pin [V]", \
"motor.motor.airGapDC.der(psi_e)", 1, 5, 170, 4)
DeclareAlias2("motor.motor.lesigma.p.i", "Current flowing into the pin [A]", \
"motor.motor.la.i", 1, 1, 0, 132)
DeclareAlias2("motor.motor.lesigma.n.v", "Potential at the pin [V]", \
"motor.motor.airGapDC.der(psi_e)", 1, 5, 170, 4)
DeclareAlias2("motor.motor.lesigma.n.i", "Current flowing into the pin [A]", \
"motor.motor.la.i", -1, 1, 0, 132)
DeclareAlias2("motor.motor.lesigma.i", "Current flowing from pin p to pin n [A]",\
 "motor.motor.la.i", 1, 1, 0, 0)
DeclareVariable("motor.motor.lesigma.L", "Inductance [H]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.motor.lesigma.quasiStatic", "No electrical transients if true [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("motor.motor.pin_ep.v", "Potential at the pin [V]", \
"motor.motor.pin_an.v", 1, 5, 68, 4)
DeclareAlias2("motor.motor.pin_ep.i", "Current flowing into the pin [A]", \
"motor.motor.la.i", 1, 1, 0, 132)
DeclareVariable("motor.motor.pin_en.v", "Potential at the pin [V]", 0, 0.0,0.0,\
0.0,0,521)
DeclareAlias2("motor.motor.pin_en.i", "Current flowing into the pin [A]", \
"motor.motor.la.i", -1, 1, 0, 132)
DeclareVariable("motor.motor.Lme", "Main part of excitation inductance [H]", \
0.0005, 0.0,0.0,0.0,0,2561)
DeclareVariable("motor.motor.Lesigma", "Stray part of excitation inductance [H]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("motor.signalVoltage.p.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,521)
DeclareAlias2("motor.signalVoltage.p.i", "Current flowing into the pin [A]", \
"motor.motor.la.i", 1, 1, 0, 132)
DeclareAlias2("motor.signalVoltage.n.v", "Potential at the pin [V]", "motor.v1", -1,\
 5, 209, 4)
DeclareAlias2("motor.signalVoltage.n.i", "Current flowing into the pin [A]", \
"motor.motor.la.i", -1, 1, 0, 132)
DeclareAlias2("motor.signalVoltage.v", "Voltage between pin p and n (= p.v - n.v) as input signal [V]",\
 "motor.v1", 1, 5, 209, 0)
DeclareAlias2("motor.signalVoltage.i", "Current flowing from pin p to pin n [A]",\
 "motor.motor.la.i", 1, 1, 0, 0)
DeclareVariable("motor.ground.p.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,\
0,521)
DeclareVariable("motor.ground.p.i", "Current flowing into the pin [A]", 0.0, \
0.0,0.0,0.0,0,777)
DeclareAlias2("motor.inertia.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "load.phi", 1, 1, 2, 4)
DeclareVariable("motor.inertia.flange_a.tau", "Cut torque in the flange [N.m]", \
0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("motor.inertia.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "load.phi", 1, 1, 2, 4)
DeclareAlias2("motor.inertia.flange_b.tau", "Cut torque in the flange [N.m]", \
"motor.flange_b1.tau", 1, 5, 208, 132)
DeclareVariable("motor.inertia.J", "Moment of inertia [kg.m2]", 1, 0.0,1E+100,\
0.0,0,513)
DeclareVariable("motor.inertia.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 3, 1.0,5.0,0.0,0,1541)
DeclareAlias2("motor.inertia.phi", "Absolute rotation angle of component [rad|deg]",\
 "load.phi", 1, 1, 2, 0)
DeclareAlias2("motor.inertia.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 "motor.inertia.w", 1, 1, 1, 0)
DeclareState("motor.inertia.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 1, 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("motor.inertia.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("motor.inertia.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "motor.inertia.der(w)", 1, 6, 1, 0)
DeclareVariable("motor.idealGear.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("motor.idealGear.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "motor.motor.inertiaRotor.phi", 1, 5, 15, 4)
DeclareAlias2("motor.idealGear.flange_a.tau", "Cut torque in the flange [N.m]", \
"motor.motor.tauShaft", 1, 5, 12, 132)
DeclareAlias2("motor.idealGear.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "load.phi", 1, 1, 2, 4)
DeclareAlias2("motor.idealGear.flange_b.tau", "Cut torque in the flange [N.m]", \
"motor.inertia.flange_a.tau", -1, 5, 202, 132)
DeclareVariable("motor.idealGear.phi_support", "Absolute angle of support flange [rad|deg]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("motor.idealGear.ratio", "Transmission ratio (flange_a.phi/flange_b.phi) [1]",\
 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("motor.idealGear.phi_a", "Angle between left shaft flange and support [rad|deg]",\
 "motor.motor.inertiaRotor.phi", 1, 5, 15, 0)
DeclareAlias2("motor.idealGear.phi_b", "Angle between right shaft flange and support [rad|deg]",\
 "load.phi", 1, 1, 2, 0)
DeclareAlias2("motor.flange_b1.phi", "Absolute rotation angle of flange [rad|deg]",\
 "load.phi", 1, 1, 2, 4)
DeclareVariable("motor.flange_b1.tau", "Cut torque in the flange [N.m]", 0.0, \
0.0,0.0,0.0,0,776)
DeclareVariable("motor.v1", "Voltage between pin p and n (= p.v - n.v) as input signal [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("motor.ratio", "Transmission ratio (flange_a.phi/flange_b.phi) [1]",\
 17, 2, 0.0,0.0,0.0,0,560)
DeclareParameter("motor.J", "Moment of inertia [kg.m2]", 18, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("speed_sp.height", "Height of ramps [rad/s]", 19, -50, 0.0,0.0,\
0.0,0,560)
DeclareParameter("speed_sp.duration", "Duration of ramp (= 0.0 gives a Step) [s]",\
 20, 10, 0.0,1E+100,0.0,0,560)
DeclareVariable("speed_sp.y", "Connector of Real output signal [rad/s]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareParameter("speed_sp.offset", "Offset of output signal y [rad/s]", 21, 200,\
 0.0,0.0,0.0,0,560)
DeclareParameter("speed_sp.startTime", "Output y = offset for time < startTime [s]",\
 22, 200, 0.0,0.0,0.0,0,560)
DeclareAlias2("PID.u_s", "Connector of setpoint input signal [rad/s]", \
"speed_sp.y", 1, 5, 210, 0)
DeclareAlias2("PID.u_m", "Connector of measurement input signal [rad/s]", \
"motor.inertia.w", 1, 1, 1, 0)
DeclareAlias2("PID.y", "Connector of actuator output signal [V]", "motor.v1", 1,\
 5, 209, 0)
DeclareVariable("PID.controlError", "Control error (set point - measurement) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("PID.controllerType", "Type of controller [:#(type=Modelica.Blocks.Types.SimpleController)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareParameter("PID.k", "Gain of controller [1]", 23, 20, 0.0,1E+100,0.0,0,560)
DeclareParameter("PID.Ti", "Time constant of Integrator block [s]", 24, 10, \
1E-60,1E+100,0.0,0,560)
DeclareParameter("PID.Td", "Time constant of Derivative block [s]", 25, 0.01, \
0.0,1E+100,0.0,0,560)
DeclareParameter("PID.yMax", "Upper limit of output", 26, 300, 0.0,0.0,0.0,0,560)
DeclareParameter("PID.yMin", "Lower limit of output", 27, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("PID.wp", "Set-point weight for Proportional block (0..1)", 28,\
 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("PID.wd", "Set-point weight for Derivative block (0..1)", 29, 0,\
 0.0,1E+100,0.0,0,560)
DeclareParameter("PID.Ni", "Ni*Ti is time constant of anti-windup compensation",\
 30, 0.9, 1E-13,1E+100,0.0,0,560)
DeclareParameter("PID.Nd", "The higher Nd, the more ideal the derivative block",\
 31, 10, 1E-13,1E+100,0.0,0,560)
DeclareVariable("PID.withFeedForward", "Use feed-forward input? [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("PID.kFF", "Gain of feed-forward input", 32, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("PID.initType", "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareParameter("PID.xi_start", "Initial or guess value for integrator output (= integrator state)",\
 33, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("PID.xd_start", "Initial or guess value for state of derivative block",\
 34, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("PID.y_start", "Initial value of output", 35, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("PID.homotopyType", "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("PID.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("PID.unitTime", "[s]", 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("PID.addP.u1", "Connector of Real input signal 1 [rad/s]", \
"speed_sp.y", 1, 5, 210, 0)
DeclareAlias2("PID.addP.u2", "Connector of Real input signal 2 [rad/s]", \
"motor.inertia.w", 1, 1, 1, 0)
DeclareVariable("PID.addP.y", "Connector of Real output signal", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("PID.addP.k1", "Gain of input signal 1", 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("PID.addP.k2", "Gain of input signal 2", 36, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("PID.P.k", "Gain value multiplied with input signal [1]", 37, 1,\
 0.0,0.0,0.0,0,560)
DeclareAlias2("PID.P.u", "Input signal connector", "PID.addP.y", 1, 5, 218, 0)
DeclareVariable("PID.P.y", "Output signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("PID.gainPID.k", "Gain value multiplied with input signal [1]", 1,\
 0.0,0.0,0.0,0,513)
DeclareVariable("PID.gainPID.u", "Input signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("PID.gainPID.y", "Output signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("PID.addPID.k1", "Gain of input signal 1", 38, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("PID.addPID.k2", "Gain of input signal 2", 39, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("PID.addPID.k3", "Gain of input signal 3", 40, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("PID.addPID.u1", "Connector of Real input signal 1", "PID.P.y", 1,\
 5, 220, 0)
DeclareVariable("PID.addPID.u2", "Connector of Real input signal 2", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("PID.addPID.u3", "Connector of Real input signal 3", "PID.I.y", 1,\
 1, 3, 0)
DeclareAlias2("PID.addPID.y", "Connector of Real output signal", "PID.gainPID.u", 1,\
 5, 222, 0)
DeclareVariable("PID.limiter.uMax", "Upper limits of input signals", 1, 0.0,0.0,\
0.0,0,513)
DeclareVariable("PID.limiter.uMin", "Lower limits of input signals", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("PID.limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("PID.limiter.homotopyType", "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("PID.limiter.u", "Connector of Real input signal", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareAlias2("PID.limiter.y", "Connector of Real output signal [V]", "motor.v1", 1,\
 5, 209, 0)
DeclareAlias2("PID.limiter.simplifiedExpr", "Simplified expression for homotopy-based initialization",\
 "PID.limiter.u", 1, 5, 229, 1024)
DeclareVariable("PID.with_I", "[:#(type=Boolean)]", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("PID.with_D", "[:#(type=Boolean)]", true, 0.0,0.0,0.0,0,1539)
DeclareParameter("PID.FFzero.k", "Constant output value", 41, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("PID.FFzero.y", "Connector of Real output signal", "PID.FFzero.k", 1,\
 7, 41, 0)
DeclareAlias2("PID.addFF.u1", "Connector of Real input signal 1", \
"PID.gainPID.y", 1, 5, 223, 0)
DeclareAlias2("PID.addFF.u2", "Connector of Real input signal 2", "PID.FFzero.k", 1,\
 7, 41, 0)
DeclareAlias2("PID.addFF.y", "Connector of Real output signal", "PID.limiter.u", 1,\
 5, 229, 0)
DeclareParameter("PID.addFF.k1", "Gain of input signal 1", 42, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("PID.addFF.k2", "Gain of input signal 2", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("load.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("load.flange.phi", "Absolute rotation angle of flange [rad|deg]", \
"load.phi", 1, 1, 2, 4)
DeclareAlias2("load.flange.tau", "Cut torque in the flange [N.m]", \
"motor.flange_b1.tau", -1, 5, 208, 132)
DeclareVariable("load.phi_support", "Absolute angle of support flange [rad|deg]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareState("load.phi", "Angle of flange with respect to support (= flange.phi - support.phi) [rad|deg]",\
 2, 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("load.der(phi)", "der(Angle of flange with respect to support (= flange.phi - support.phi)) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("load.tau_nominal", "Nominal torque (if negative, torque is acting as load in positive direction of rotation) [N.m]",\
 43, -10, 0.0,0.0,0.0,0,560)
DeclareVariable("load.TorqueDirection", "Same direction of torque in both directions of rotation [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("load.w_nominal", "Nominal speed [rad/s]", 44, 200, 1E-15,\
1E+100,0.0,0,560)
DeclareAlias2("load.w", "Angular velocity of flange with respect to support (= der(phi)) [rad/s]",\
 "load.der(phi)", 1, 6, 2, 0)
DeclareAlias2("load.tau", "Accelerating torque acting at flange (= -flange.tau) [N.m]",\
 "motor.flange_b1.tau", 1, 5, 208, 0)
DeclareAlias2("speedSensor.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "load.phi", 1, 1, 2, 4)
DeclareAlias2("speedSensor.flange.der(phi)", "der(Absolute rotation angle of flange) [rad/s]",\
 "motor.inertia.w", 1, 1, 1, 4)
DeclareVariable("speedSensor.flange.tau", "Cut torque in the flange [N.m]", 0, \
0.0,0.0,0.0,0,777)
DeclareAlias2("speedSensor.w", "Absolute angular velocity of flange as output signal [rad/s]",\
 "motor.inertia.w", 1, 1, 1, 0)
DeclareAlias2("PID.addD.u1", "Connector of Real input signal 1 [rad/s]", \
"speed_sp.y", 1, 5, 210, 0)
DeclareAlias2("PID.addD.u2", "Connector of Real input signal 2 [rad/s]", \
"motor.inertia.w", 1, 1, 1, 0)
DeclareVariable("PID.addD.y", "Connector of Real output signal", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("PID.addD.k1", "Gain of input signal 1", 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("PID.addD.k2", "Gain of input signal 2", 45, -1, 0.0,0.0,0.0,0,560)
DeclareVariable("PID.I.k", "Integrator gain [1]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("PID.I.use_reset", "= true, if reset port enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("PID.I.use_set", "= true, if set port enabled and used as reinitialization value when reset [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("PID.I.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("PID.I.y_start", "Initial or guess value of output (= state)", \
0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("PID.I.u", "Connector of Real input signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareState("PID.I.y", "Connector of Real output signal", 3, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("PID.I.der(y)", "der(Connector of Real output signal)", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("PID.I.local_reset", "[:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("PID.I.local_set", "", 0, 0.0,0.0,0.0,0,1537)
DeclareVariable("PID.D.k", "Gains [1]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("PID.D.T", "Time constants (T>0 required; T=0 is ideal derivative block) [s]",\
 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("PID.D.initType", "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("PID.D.x_start", "Initial or guess value of state", 0.0, \
0.0,0.0,0.0,0,513)
DeclareParameter("PID.D.y_start", "Initial value of output (= state)", 46, 0, \
0.0,0.0,0.0,0,560)
DeclareAlias2("PID.D.u", "Connector of Real input signal", "PID.addD.y", 1, 5, 237,\
 0)
DeclareAlias2("PID.D.y", "Connector of Real output signal", "PID.addPID.u2", 1, 5,\
 224, 0)
DeclareState("PID.D.x", "State of block", 4, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("PID.D.der(x)", "der(State of block)", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("PID.D.zeroGain", "[:#(type=Boolean)]", false, 0.0,0.0,0.0,0,2563)
DeclareParameter("PID.addI.k1", "Gain of input signal 1", 47, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("PID.addI.k2", "Gain of input signal 2", 48, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("PID.addI.k3", "Gain of input signal 3", 49, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("PID.addI.u1", "Connector of Real input signal 1 [rad/s]", \
"speed_sp.y", 1, 5, 210, 0)
DeclareAlias2("PID.addI.u2", "Connector of Real input signal 2 [rad/s]", \
"motor.inertia.w", 1, 1, 1, 0)
DeclareVariable("PID.addI.u3", "Connector of Real input signal 3", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareAlias2("PID.addI.y", "Connector of Real output signal", "PID.I.u", 1, 5, 244,\
 0)
DeclareAlias2("PID.addSat.u1", "Connector of Real input signal 1 [V]", \
"motor.v1", 1, 5, 209, 0)
DeclareAlias2("PID.addSat.u2", "Connector of Real input signal 2", \
"PID.limiter.u", 1, 5, 229, 0)
DeclareVariable("PID.addSat.y", "Connector of Real output signal", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareParameter("PID.addSat.k1", "Gain of input signal 1", 50, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("PID.addSat.k2", "Gain of input signal 2", 51, -1, 0.0,0.0,0.0,\
0,560)
DeclareVariable("PID.gainTrack.k", "Gain value multiplied with input signal [1]",\
 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("PID.gainTrack.u", "Input signal connector", "PID.addSat.y", 1, 5,\
 253, 0)
DeclareAlias2("PID.gainTrack.y", "Output signal connector", "PID.addI.u3", 1, 5,\
 252, 0)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
}
StartDataBlock
StartEqBlock
DoRemember_(DYNX(F_,1), 0.0, 0);
DoRemember_(DYNX(F_,0), 0.0, 1);
EndEqBlock
EndDataBlock

BreakSectionFunctionStart(0);
BreakSectionFunctionCallNew(1);
BreakSectionFunctionEnd()
